#!/bin/ksh
# Script: c4 (Continental Cluster Configuration Checker or c4)
# License: GPLv3
# Author: Gratien D'haese - gdhaese1 at its.jnj.com

#
# Parameters
#
PS4='$LINENO:=> ' # This prompt will be used when script tracing is turned on
typeset -x PRGNAME=${0##*/}                             # This script short name
typeset -x PRGDIR=$(dirname $0)                         # This script directory name
[[ $PRGDIR = /* ]] || {                                 # Acquire absolute path to the script
        case $PRGDIR in
                . ) PRGDIR=$(pwd) ;;
                * ) PRGDIR=$(pwd)/$PRGDIR ;;
        esac
        }
typeset -x ARGS="$@"                                    # the script arguments
[[ -z "$ARGS" ]] && ARGS="(empty)"                      # is used in the header
typeset -x PATH=/usr/local/CPR/bin:/sbin:/usr/sbin:/usr/bin:/usr/xpg4/bin:$PATH:/usr/ucb:.
typeset -r platform=$(uname -s)                         # Platform
typeset -r model=$(uname -m)                            # Model
typeset -r HOSTNAME=$(uname -n)                         # hostname
typeset os=$(uname -r); os=${os#B.}                     # e.g. 11.31

typeset -x	ERRcode=0				# exit code (default 0)
typeset -r	CMVIEWCONCL=/usr/sbin/cmviewconcl
typeset -r	CMVIEWCL=/usr/sbin/cmviewcl
typeset -r	CMGETPKGENV=/usr/sbin/cmgetpkgenv
typeset -r	SWLIST=/usr/sbin/swlist
typeset -r	CONCLUSR=conclusr			# the cc user

typeset -r	LOGFILE=/var/tmp/$PRGNAME-$(date '+%Y%m%d-%H%M').log
typeset		TMPDIR=$( mktemp -d /tmp -p ${PRGNAME}.$$ )
typeset         TMPFILE1=$TMPDIR/${PRGNAME}_1.$$
typeset         TMPFILE2=$TMPDIR/${PRGNAME}_2.$$
typeset		CCCONFIG_FILE=$TMPDIR/CCCONFIG_FILE.$$
typeset		CCCONPKG_FILE=$TMPDIR/CCCONPKG_FILE.$$
typeset		PRIMARY_CONF_FILE=$TMPDIR/PRIMARY_CONF_FILE.$$
typeset		RECOVERY_CONF_FILE=$TMPDIR/RECOVERY_CONF_FILE.$$

#
# Functions
#
function _check_continental_cluster_software
{
    # T2346BA  A.08.00.00     HP Continentalclusters
    $SWLIST T2346BA,r\>=A.08.00.00 >/dev/null 2>&1
    return $?
}

function _echo
{
	case $platform in
		Linux|Darwin) arg="-e " ;;
	esac
	echo $arg "$*"
} # echo is not the same between UNIX and Linux

function _note
{
	_echo " ** $*"
} 

function _error
{
	printf " *** ERROR: $* \n"
	_cleanup_tmp_files
	exit 1
}

function _warning
{
	printf " *** WARN: $* \n"
}

function _ok
{
	echo "[  OK  ]"
}

function _nok
{
	ERRcode=$((ERRcode + 1))
	echo "[FAILED]"
}

function _skip
{
	echo "[ SKIP ]"
}

function _warn
{
	echo "[ WARN ]"
}

function _askYN
{
	# input arg1: string Y or N; arg2: string to display
	# output returns 0 if NO or 1 if YES so you can use a unary test for comparison
	typeset answer

	case "$1" in
		Y|y)	order="Y/n" ;;
		*)	order="y/N" ;;
	esac

	_echo "$2 $order ? \c"
	read answer

	case "$1" in
		Y|y)
			if [[ "${answer}" = "n" ]] || [[ "${answer}" = "N" ]]; then
				return 0
			else
				return 1
			fi
			;;
		*)
			if [[ "${answer}" = "y" ]] || [[ "${answer}" = "Y" ]]; then
				return 1
			else
				return 0
			fi
			;;
	esac

}

function _line
{
	typeset -i i
	while (( i < 95 )); do
		(( i+=1 ))
		echo "${1}\c"
	done
	echo
}

function _banner
{
	# arg1 "string to print next to Purpose"
	cat - <<-EOD
	$(_line "#")
	$(_print 22 "Script:" "$PRGNAME")
	$(_print 22 "Arguments:" "$ARGS")
	$(_print 22 "Purpose:" "$1")
	$(_print 22 "OS Release:" "$os")
	$(_print 22 "Model:" "$model")
	$(_print 22 "Host:" "$HOSTNAME")
	$(_print 22 "User:" "$(whoami)")
	$(_print 22 "Date:" "$(date +'%Y-%m-%d @ %H:%M:%S')")
	$(_line "#")
	EOD
}

function _print
{
	# arg1: counter (integer), arg2: "left string", arg3: "right string"
	typeset -i i
	i=$(_isnum $1)
	[[ $i -eq 0 ]] && i=22	# if i was 0, then make it 22 (our default value)
	printf "%${i}s %-80s " "$2" "$3"
}

function _whoami
{
	if [ "$(whoami)" != "root" ]; then
		_error "$(whoami) - You must be root to run this script $PRGNAME"
	fi
}

function _osrevision
{
	case $platform in
		HP-UX) : ;;
		*) _error "Script $PRGNAME does not support platform $platform" ;;
	esac
	_print 3 "**" "Running on $platform $os" ; _ok
}

function _is_var_empty
{
	[[ -z "$1" ]] && return 1
	return 0
}

function _date
{
	echo $(date '+%Y-%b-%d')	# format: 2012-Aug-06
}

function _my_grep
{
	# input arg1: "string to find" arg2: "string to be searched"
	echo "$2" | grep -q "$1"  && echo 1 || echo 0
}

function _isnum
{
	echo $(($1+0))		# returns 0 for non-numeric input, otherwise input=output
}


# MASKS array is used to find the CIDR number
set -A MASKS \
        0 \
        2147483648 3221225472 3758096384 4026531840 \
        4160749568 4227858432 4261412864 4278190080 \
        4286578688 4290772992 4292870144 4293918720 \
        4294443008 4294705152 4294836224 4294901760 \
        4294934528 4294950912 4294959104 4294963200 \
        4294965248 4294966272 4294966784 4294967040 \
        4294967168 4294967232 4294967264 4294967280 \
        4294967288 4294967292 4294967294 4294967295 \
        -1


function _my_ipcalc
{
    typeset -i BITS ADDRESS="$(_ip2num "$1")"

    if [[ ! -z "$2" ]]; then
        typeset -i i=0 DEC MASK="$(_ip2num "$2")"
        while [[ $i -le 32 ]]; do
             DEC=${MASKS[$i]}
             (( MASK == DEC )) && break
             i=$(( i + 1))
        done
        (( DEC < 0 )) && _error "Main: netmask [$2] seems to be invalid."
        NETADDR=$(_num2ip "$(( ADDRESS & MASK ))")
        BITS=$i
    else
        NETADDR=$(_num2ip "$ADDRESS")
        BITS=32
    fi
    echo "$NETADDR/$BITS"
}

function _quad2num
{
    if [ $# -eq 4 ]; then
        let n="${1} << 24 | ${2} << 16 | ${3} << 8 | ${4}"
        echo "${n}"
        return 0
    else
        echo "0"
        return 1
    fi
}

function _ip2num
{
	IFS="."
	_quad2num ${1}
}

function _num2ip
{
     num="$1"
     d=$(($num % 256))
     c=$(( ($num >> 8 ) % 256 ))
     b=$(( ($num >> 16) % 256 ))
     a=$(( ($num >> 24) % 256 ))
     echo "$a.$b.$c.$d"
}

function _get_network_address
{
    # get network address for the given IP address and (netmask or prefix)
    # CIDR notation
    ip="$1"
    nm="$2"

    if [ -n "$ip" -a -n "$nm" ]; then
        if [[ "$nm" = *.* ]]; then
            :
        else
            nm=$( _prefix2netmask ${nm} )
        fi
        _my_ipcalc ${ip} ${nm} | cut -d '/' -f 2
    fi
}

function _prefix2netmask
{
	pf="$1"
	echo $(_num2ip "${MASKS[$pf]}")
}

function _get_prefix
{
    # get prefix for the given IP address and mask
    ip="$1"
    nm="$2"

    if [ -n "$ip" -a -n "$nm" ]; then
        _my_ipcalc ${ip} ${nm} | cut -d '/' -f 2
    fi
}

function _validOS
{
	[[ "$os" = "11.31" ]] || _error "$PRGNAME only run on HP-UX 11.31 (and not on $os)"
	_osrevision
}

function _validSG
{
	release=$(/usr/sbin/swlist T1905CA.ServiceGuard | tail -1 | awk '{print $2}')
	rc=$(_my_grep "A.11.20" $release)
	if [[ $rc -eq 1 ]]; then
		_print 3 "**" "Serviceguard $release is valid" ; _ok
	else
		_error "Serviceguard $release is not valid (expecting A.11.20.*)"
	fi
}

function _validSGeSAP
{
	release=$(/usr/sbin/swlist T2803BA | tail -1 | awk '{print $2}')
	rc=$(_my_grep "B.05.10" $release)
	if [[ $rc -eq 1 ]]; then
		_print 3 "**" "Serviceguard Extension for SAP $release is valid" ; _ok
	else
		_print 3 "==" "Serviceguard Extension for SAP $release is not valid (expecting B.05.10)"; _warn
	fi
}

function _validCluster
{
	out=$(cmviewcl -l cluster 2>&1 | tail -1)
	echo $out | grep -q up
	rc=$?
	if [[ $rc -eq 0 ]]; then
		_print 3 "**" "A valid cluster $(echo $out | awk '{print $1}') found, which is running (up)" ; _ok
		#_print 3 " "  "$out"
		#printf "\n"	# to have a proper linefeed
	else
		_error "Cluster is not up or not configured (yet)"
	fi
}

function _check_nslookup_address
{
	# input arg: name
	# output: 0=true (name resolvable); 1=false (name not found)
	nslookup "$1" > /tmp/_check_nslookup_address.txt 2>&1
	grep -q "^Address:" /tmp/_check_nslookup_address.txt && return 0
	return 1
}

function _debug
{
	test "$DEBUG" && _note "$@"
}

function _find_and_print_x_lines
{
	# find a keyword (string) and print x nr of lines after that keyword (line of keyword included)
	# input args: $1 (string to find); $2=integer (amount of lines); $3=filename to search in
	# output: lines of text 
	awk '/'"$1"'/ {p = '"$2"'} p > 0  {print $0; p--}' $3
}

function _cmp_banner
{
	printf "primary cluster: $PRIM_CL                                      recovery cluster: $REC_CL\n"
	_line "~"
}

function _compare_general_parameters
{
	# compare the general cluster parameters between primary and recovery cluster
	# input args: none
	# output:
	grep -v -E '(name=|^node|^package|node:|^id=|^cluster_formation_time|^coordinator|^logout)' \
	$PRIMARY_CONF_FILE > $TMPFILE1
	grep -v -E '(name=|^node|^package|node:|^id=|^cluster_formation_time|^coordinator|^logout)' \
	$RECOVERY_CONF_FILE > $TMPFILE2
	cmp -s $TMPFILE1 $TMPFILE2
	if [[ $? -eq 1 ]]; then
		_print 3 "==" "The general cluster parameters do not match between $PRIM_CL and $REC_CL" ; _nok
		_cmp_banner
		sdiff -s $TMPFILE1 $TMPFILE2
	else
		_print 3 "**" "The general cluster parameters match between $PRIM_CL and $REC_CL" ; _ok
	fi
	echo
}

function _compare_node_parameters
{
	# it is the purpose to compare node1 from primary cluster with node1 from recovery cluster
	# keep in mind that IP addresses will be different
	# input args: none
	# output:
	count_prim_cl=${#PRIMARY_NODES[@]}  # amount of nodes in array
	count_rec_cl=${#RECOVERY_NODES[@]}  # amount of nodes in array
	if [[ $count_prim_cl -ne $count_rec_cl ]]; then
		# TODO: should this become an _error?
		_print 3 "==" "The amount of nodes between primary cluster ($count_prim_cl) and recovery cluster ($count_rec_cl) is not equal" ; _nok
	fi

	# NODE contains the FQDN (the PRIMARY_CONF_FILE only contains the short hostname) -> ${NODE%%.*}
	j=0  # counter for our PRIM_IP, PRIM_NM and PRIM_SN arrays (to compare primary/recovery sides)
	for NODE in $( echo ${PRIMARY_NODES[@]} )
	do
		# grep only lines starting with "node" and $(hostname) and remove "node:$(hostname)|" too
		grep "^node" $PRIMARY_CONF_FILE | grep ${NODE%%.*} | cut -d'|' -f2- | \
		grep -v -E '(node_pr_key|boot_timestamp|mac_address)' > $TMPDIR/${NODE%%.*}
		# to be able to compare we have to remove (or change) the subnets of the node, e.g. subnet 10.0.208 vs. 10.0.210
		grep ip_address $TMPDIR/${NODE%%.*} | while read LINE
		do
			echo $LINE | grep -q "name=" && PRIM_IP[$j]=$( echo $LINE | grep "name=" | cut -d= -f2 )
			echo $LINE | grep -q "netmask=" && PRIM_NM[$j]=$( echo $LINE | grep "netmask=" | cut -d= -f2 )
			echo $LINE | grep -q "subnet=" && {
				PRIM_SN[$j]=$( echo $LINE | grep "subnet=" | cut -d= -f2 )
				# after subnet line we may increase of index j
				j=$(( j + 1 ))
				}
		done
	done
	# the polling_target is the default gateway (and per cluster it must be the same for all nodes)
	PRIM_GW=$( grep subnet $TMPDIR/${NODE%%.*} | grep polling_target | cut -d= -f2 )

	j=0  # reset our array counter fro REC_IP, REC_NM and REC_SN
	for NODE in $( echo ${RECOVERY_NODES[@]} )
	do
		# grep only lines starting with "node" and $(hostname) and remove "node:$(hostname)|" too
		grep "^node" $RECOVERY_CONF_FILE | grep ${NODE%%.*} | cut -d'|' -f2- | \
		grep -v -E '(node_pr_key|boot_timestamp|mac_address)' > $TMPDIR/${NODE%%.*}
		grep ip_address $TMPDIR/${NODE%%.*} | while read LINE
		do
			echo $LINE | grep -q "name=" && REC_IP[$j]=$( echo $LINE | grep "name=" | cut -d= -f2 )
			echo $LINE | grep -q "netmask=" && REC_NM[$j]=$( echo $LINE | grep "netmask=" | cut -d= -f2 )
			echo $LINE | grep -q "subnet=" && {
				REC_SN[$j]=$( echo $LINE | grep "subnet=" | cut -d= -f2 )
				# after subnet line we may increase of index j
				j=$(( j + 1 ))
				}
		done
		# take a backup copy of recovery node file (as we will change the IP addresses etc)
		cp $TMPDIR/${NODE%%.*} $TMPDIR/${NODE%%.*}.orig
	done
	REC_GW=$( grep subnet $TMPDIR/${NODE%%.*} | grep polling_target | cut -d= -f2 )

	# to be able to compare we will replace the recovery node IP addresses (REC_IPs) with the PRIM_IPs
	count=${#REC_IP[@]}	# count the elements in array
	i=0
	while [[ $i -le $count ]]
	do
		for NODE in $( echo ${RECOVERY_NODES[@]} )
		do
			sed -e "s/${REC_IP[i]}/${PRIM_IP[i]}/g" -e "s/${REC_NM[i]}/${PRIM_NM[i]}/g" \
			-e "s/${REC_SN[i]}/${PRIM_SN[i]}/g" -e "s/${REC_GW}/${PRIM_GW}/g" \
			< $TMPDIR/${NODE%%.*} >$TMPDIR/${NODE%%.*}-tmp
			mv $TMPDIR/${NODE%%.*}-tmp $TMPDIR/${NODE%%.*}
		done
		i=$(( i + 1 ))
	done

	# remove the "name=" line from each input node file (to make comparing easier)
	for NODE in $( echo ${PRIMARY_NODES[@]} ${RECOVERY_NODES[@]} )
	do
		sed -e "/^name=/d" < $TMPDIR/${NODE%%.*} >$TMPDIR/${NODE%%.*}-tmp
		mv $TMPDIR/${NODE%%.*}-tmp $TMPDIR/${NODE%%.*}
	done
	# now we have to compare node per equivalent node between primary and recovery cluster
	i=0     # the first node name in array
	while [[ $i -lt $count_prim_cl ]]
	do
		cmp -s $TMPDIR/${PRIMARY_NODES[$i]%%.*} $TMPDIR/${RECOVERY_NODES[$i]%%.*}
		if [[ $? -eq 1 ]]; then
			_print 3 "==" "Node ${PRIMARY_NODES[$i]%%.*} differs from ${RECOVERY_NODES[$i]%%.*}" ; _nok
			_cmp_banner
			sdiff -s $TMPDIR/${PRIMARY_NODES[$i]%%.*} $TMPDIR/${RECOVERY_NODES[$i]%%.*}
		else
			_print 3 "**" "Node ${PRIMARY_NODES[$i]%%.*} is equal to ${RECOVERY_NODES[$i]%%.*}" ; _ok
		fi
		i=$((i+1))
		echo
	done
	
}

function _compare_package_of_group
{
	# purpose is to compare package configuration of group $1 between primary and recover cluster
	# packages should be equal
	# input argument $1:group
	# output: done inside function
	GROUP="$1"
	# give the file a prefix "group_" as group name can be anything
	_find_and_print_x_lines "$GROUP" 5 $CCCONFIG_FILE > "$TMPDIR/group_$GROUP"
	_note "Start analyzing package recovery group \"$GROUP\""
	_line "*"
	cat "$TMPDIR/group_$GROUP"
	echo
	# PACKAGE RECOVERY GROUP  Group001
	#
	#    PACKAGE                           ROLE           STATUS
	#    treasury_lab/GTSLORA1             primary        up
	#    treasury_lab_dr/GTSLORA1          recovery       down
	PACKAGENAME=$( tail -1 $TMPDIR/group_$GROUP | awk '{print $1}' | cut -d"/" -f2 )
	grep "^package:${PACKAGENAME}" $PRIMARY_CONF_FILE  > "$TMPDIR/pkg_${PACKAGENAME}_PRIM"
	grep "^package:${PACKAGENAME}" $RECOVERY_CONF_FILE > "$TMPDIR/pkg_${PACKAGENAME}_REC"

	_filter_package_output_of "$TMPDIR/pkg_${PACKAGENAME}_PRIM" 0
	_filter_package_output_of "$TMPDIR/pkg_${PACKAGENAME}_REC"  1

	cmp -s "$TMPDIR/pkg_${PACKAGENAME}_PRIM" "$TMPDIR/pkg_${PACKAGENAME}_REC"
	if [[ $? -eq 1 ]]; then
		_print 3 "==" "Package ${PACKAGENAME} differs between primary and recovery cluster" ; _nok
		_cmp_banner
		sdiff -s "$TMPDIR/pkg_${PACKAGENAME}_PRIM" "$TMPDIR/pkg_${PACKAGENAME}_REC"
	else
		_print 3 "**" "Package ${PACKAGENAME} is exactly the same between primary and recovery cluster" ; _ok
	fi
	echo
}

function _filter_package_output_of
{
	# purpose of function is to remove lines from the pkg_${PACKAGENAME}_<PRIM|REC> file
	# so it becomes easier to compare them
	# input: pkg_${PACKAGENAME}_<PRIM|REC> file, arg2: trigger (1) to replace nodenames, IPs
	# output: pkg_${PACKAGENAME}_<PRIM|REC> file rewritten

	# first we remove "package:<PACKAGENAME>|" from input stream and some keywords
	cat $1 | cut -d'|' -f2- | grep -v -E '(^name=|^owner=|^id=|^ip_address:|^summary=)' | \
	grep -v -E '(last_run_time=|last_halt_time=|status=|state=|available=|pid=|restart_limit=)' | \
	rmnl | ssp > ${1}.new
	mv -f ${1}.new ${1}

	if [[ $2 -eq 0 ]]; then
		# grab the PKG_PRIM_IP from package file; as prim cluster may not be the active one use subnet line
		i=0
		grep ^ip_subnet ${1} | grep ip_address | while read LINE
		do
			PKG_PRIM_IP[$i]=$( echo $LINE | cut -d= -f2 )
			i=$(( i + 1 ))
		done
		

		return   # we will not change nodes names nor IP addresses in recovery package file
	fi

	# $2=1 => recovery package file
	i=0
	grep ^ip_subnet ${1} | grep ip_address | while read LINE
	do
		PKG_REC_IP[$i]=$( echo $LINE | cut -d= -f2 )
		i=$(( i + 1 ))
	done

	i=0
	while [[ $i -le ${#RECOVERY_NODES[@]} ]]
	do
		NODE_PRIM=${PRIMARY_NODES[i]%%.*}  # use the short primary hostname
		NODE_REC=${RECOVERY_NODES[i]%%.*}  # use the short primary hostname
		sed -e "s/$NODE_REC/$NODE_PRIM/g" < ${1} > ${1}.new
		mv -f ${1}.new ${1}
		i=$(( i + 1 ))
	done

	# to be able to compare we will replace the recovery node IP addresses (REC_IPs) with the PRIM_IPs
	i=0
	while [[ $i -le ${#REC_IP[@]} ]]
	do
		sed -e "s/${REC_IP[i]}/${PRIM_IP[i]}/g" -e "s/${REC_NM[i]}/${PRIM_NM[i]}/g" \
		-e "s/${REC_SN[i]}/${PRIM_SN[i]}/g" -e "s/${REC_GW}/${PRIM_GW}/g" \
		< ${1} > ${1}.new
		mv -f ${1}.new ${1}
		i=$(( i + 1 ))
	done

	# for SAP webdispatchers multiple IP addresses may be defined
	i=0
	while [[ $i -le ${#PKG_REC_IP[@]} ]]
	do
		sed -e "s/${PKG_REC_IP[i]}/${PKG_PRIM_IP[i]}/g" < ${1} > ${1}.new
		mv -f ${1}.new ${1}
		i=$(( i + 1 ))
	done
}

function _cleanup_tmp_files
{
	rm -f $TMPFILE1 $CCCONPKG_FILE $TMPFILE2 $CCCONFIG_FILE
	rm -f /tmp/_check_nslookup_address.txt
}

###############################################################################
###
### MAIN
###
###############################################################################

_whoami
_banner "Continental Cluster Consistency Checks"
_validOS

# create the TMPDIR
[[ -d $TMPDIR ]] && rm -rf $TMPDIR    # remove old TMPDIR
mkdir -p $TMPDIR || _error "Could not create the temporary directory $TMPDIR"
chmod 755 $TMPDIR

###############################################################################
_check_continental_cluster_software
if [[ $? -eq 0 ]]; then
    _print 3 "**" "Continental Cluster Software T2346BA,r=>A.08.00.00 present" ; _ok
else
    _error "Continental Cluster Software T2346BA not present or release <A.08.00.00"
fi

# check if SG 11.20 is installed
_validSG

###############################################################################
# do we have the cmviewconcl command present? The $CCCONFIG_FILE will be used later
type $CMVIEWCONCL >/dev/null 2>&1
if [[ $? -eq 0 ]]; then
    _print 3 "**" "Collecting output of command $CMVIEWCONCL"
    $CMVIEWCONCL >$CCCONFIG_FILE 2>&1
    if [[ $? -eq 0 ]]; then
        _ok
    else
        _nok
    fi
else
   _error "Required Command $CMVIEWCONCL not found"
fi

###############################################################################
# Do we have the conclusr locally defined in the passwd file?
grep ^${CONCLUSR} /etc/passwd >/dev/null 2>&1
if [[ $? -eq 0 ]]; then
    _print 3 "**" "Continental Cluster user ${CONCLUSR} is present on this node $HOSTNAME" ; _ok
else
    _error "Continental Cluster user ${CONCLUSR} seems to be unknown"
fi

###############################################################################
# show continental cluster name
CC_NAME=$( grep "^CONTINENTAL CLUSTER" $CCCONFIG_FILE | awk '{print $3,$4}' )
if [[ ! -z "$CC_NAME" ]]; then
    _print 3 "**" "Continental Cluster name is $CC_NAME" ; _ok
else
    _print 3 "==" "Continental Cluster name is unknown" ; _nok
fi

###############################################################################
# get names of primary and recovery cluster
PRIM_CL=$( _find_and_print_x_lines "PRIMARY CLUSTER" 2 $CCCONFIG_FILE | tail -1 | awk '{print $1}' )
REC_CL=$( grep "RECOVERY CLUSTER" $CCCONFIG_FILE | awk '{print $3}' )
if [[ ! -z "$PRIM_CL" ]]; then
    _print 3 "**" "Primary cluster name is $PRIM_CL" ; _ok
else
   _print 3 "==" "Primary cluster name is unknown" ; _nok
fi
if [[ ! -z "$REC_CL" ]]; then
    _print 3 "**" "Recovery cluster name is $REC_CL" ; _ok
else
    _print 3 "==" "Recovery cluster name is unknown" ; _nok
fi

###############################################################################
# Show which cluster is active and define ACTIVE_CL variable
PRIM_CL_STATUS=$( _find_and_print_x_lines "PRIMARY CLUSTER" 2 $CCCONFIG_FILE | tail -1 | awk '{print $2}' )
if [[ ! -z "$PRIM_CL_STATUS" ]]; then
    if [[ "$PRIM_CL_STATUS" = "up" ]]; then
        _print 3 "**" "Primary cluster ($PRIM_CL) status is \"$PRIM_CL_STATUS\"" ; _ok
        ACTIVE_CL=$PRIM_CL
    else
        _print 3 "**" "Primary cluster ($PRIM_CL) status is \"$PRIM_CL_STATUS\"" ; _warn
        # check now if recovery cluster is up!
        grep recovery $CCCONFIG_FILE | grep -q up
        if [[ $? -eq 0 ]]; then
            _print 3 "**" "Recovery cluster ($REC_CL) status is \"up\"" ; _ok
            ACTIVE_CL=$REC_CL
        else
            _print 3 "==" "Recovery cluster status is down" ; _nok
            ACTIVE_CL=""
        fi
    fi
else
    _print 3 "==" "Primary and recovery cluster status are not known" ; _nok
    ACTIVE_CL=""
fi

###############################################################################
# verify if ccconfpkg package is available (we need this to find all the nodes on both sides)
$CMVIEWCL -f line -v -p ccconfpkg > $CCCONPKG_FILE 2>&1
if [[ $? -eq 0 ]]; then
    _print 3 "**" "Continental Cluster Configuration package ccconfpkg is available" ; _ok
else
    _error "Continental Cluster Configuration package ccconfpkg not found"
fi

###############################################################################
# collect the nodes of the PRIMARY CLUSTER (use file $CCCONPKG_FILE to retrieve the nodes)
set -A PRIMARY_NODES $( grep "dts/ccconf/CLUSTER_NAME:${PRIM_CL}|dts/ccconf/CC_NODE_NAME=" $CCCONPKG_FILE | cut -d= -f2 )
if [[ ${#PRIMARY_NODES[@]} -gt 0 ]]; then
    _print 3 "**" "Primary Cluster nodes are $(echo ${PRIMARY_NODES[@]})" ; _ok
else
    _print 3 "==" "Primary Cluster [$PRIM_CL] has no nodes defined" ; _nok
fi

###############################################################################
# collect the nodes of the RECOVERY CLUSTER (use file $CCCONPKG_FILE to retrieve the nodes)
set -A RECOVERY_NODES $( grep "dts/ccconf/CLUSTER_NAME:${REC_CL}|dts/ccconf/CC_NODE_NAME=" $CCCONPKG_FILE | cut -d= -f2 )
if [[ ${#RECOVERY_NODES[@]} -gt 0 ]]; then
    _print 3 "**" "Recovery Cluster nodes are $(echo ${RECOVERY_NODES[@]})" ; _ok
else
    _print 3 "==" "Recovery Cluster [$REC_CL] has no nodes defined" ; _nok
fi

###############################################################################
# run ssh connectivity tests towards all remotes nodes for the CONCLUSR user
# Primary nodes & when successfull grab the output of the cluster running

### TODO: must become a function
for NODE in $( echo ${PRIMARY_NODES[@]} )
do
    su - $CONCLUSR -c "ssh  -n -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=false -l $CONCLUSR $NODE  hostname" > $TMPFILE2 2>$TMPFILE2
    if [[ $? -eq 0 ]]; then
        _print 3 "**" "User $CONCLUSR can execute commands on node $NODE" ; _ok
        # ssh works so now we can collect the output from cmviewcl -v via $CONCLUSR
        su - $CONCLUSR -c "ssh -q -n -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=false \
        -l $CONCLUSR $NODE /usr/sbin/cmviewcl -f line -v" > "$PRIMARY_CONF_FILE" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            # we print the short hostname with ${NODE%%.*}
            _print 3 "**" "Save the configuration of cluster $PRIM_CL (via node ${NODE%%.*})" ; _ok
        else
            _print 3 "==" "Save the configuration of cluster $PRIM_CL (via node ${NODE%%.*})" ; _nok
        fi
    else
        _print 3 "==" "User $CONCLUSR can execute commands on node ${NODE%%.*}" ; _nok
        grep -q "Account" $TMPFILE2 && _note "$(grep Account $TMPFILE2)"
    fi
done

# Recovery nodes & when successfull grab the output of the cluster running
for NODE in $( echo ${RECOVERY_NODES[@]} )
do
    su - $CONCLUSR -c "ssh  -n -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=false -l $CONCLUSR $NODE  hostname" > $TMPFILE2 2>$TMPFILE2
    if [[ $? -eq 0 ]]; then
        _print 3 "**" "User $CONCLUSR can execute commands on node $NODE" ; _ok
        # ssh works so now we can collect the output from cmviewcl -v via $CONCLUSR
        su - $CONCLUSR -c "ssh -q -n -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=false \
        -l $CONCLUSR $NODE /usr/sbin/cmviewcl -f line -v" > "$RECOVERY_CONF_FILE" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            _print 3 "**" "Save the configuration of cluster $REC_CL (via node ${NODE%%.*})" ; _ok
        else
            _print 3 "==" "Save the configuration of cluster $REC_CL (via node ${NODE%%.*})" ; _nok
        fi
    else
        _print 3 "==" "User $CONCLUSR can execute commands on node ${NODE%%.*}" ; _nok
        grep -q "Account" $TMPFILE2 && _note "$(grep Account $TMPFILE2)"
    fi
done


###############################################################################
# Check if we have a valid cluster configuration overview of the primary site
### TODO: make a function for this
if [[ -f $PRIMARY_CONF_FILE ]]; then
    # we will first remove the login banner from the cmviewcl output
    #cat $PRIMARY_CONF_FILE | \
    #awk "/name=$PRIM_CL/,/logout/ {if (\$0 !~ "name=$PRIM_CL" && \$0 !~ "logout") print}" \
    #> $TMPFILE2
    #cp $TMPFILE2 $PRIMARY_CONF_FILE
    # verify if the output makes sense by grepping "network_failure_detection" string (as
    # we are sure this must be in there)
    grep -q "network_failure_detection" $PRIMARY_CONF_FILE
    if [[ $? -eq 0 ]]; then
        _print 3 "**" "The configuration of cluster $PRIM_CL seems valid" ; _ok
    else
        # if the input file is invalid no need to continue
        _error "The configuration of cluster $PRIM_CL seems invalid - see file $PRIMARY_CONF_FILE"
    fi
else
    _error "The configuration of cluster $PRIM_CL was not created??"
fi

###############################################################################
# Check if we have a valid cluster configuration overview of the recovery site
if [[ -f $RECOVERY_CONF_FILE ]]; then
    # we will first remove the login banner from the cmviewcl output
    #cat $RECOVERY_CONF_FILE | \
    #awk "/name=$REC_CL/,/logout/ {if (\$0 !~ "name=$REC_CL" && \$0 !~ "logout") print}" \
    #> $TMPFILE2
    #cp $TMPFILE2 $RECOVERY_CONF_FILE
    # verify if the output makes sense by grepping "network_failure_detection" string (as
    # we are sure this must be in there)
    grep -q "network_failure_detection" $RECOVERY_CONF_FILE
    if [[ $? -eq 0 ]]; then
        _print 3 "**" "The configuration of cluster $REC_CL seems valid" ; _ok
    else
        # if the input file is invalid no need to continue
        _error "The configuration of cluster $REC_CL seems invalid - see file $RECOVERY_CONF_FILE"
    fi
else
    _error "The configuration of cluster $REC_CL was not created??"
fi

###############################################################################
# Start comparing the primary and recovery cluster configuration
# part: general parameters
_compare_general_parameters

###############################################################################
# Start comparing the node parameters
# part: node paramaters
_compare_node_parameters


###############################################################################
# part: go over the package groups
for GROUP in $( grep "PACKAGE RECOVERY GROUP" $CCCONFIG_FILE | awk '{print $4}' )
do
	_compare_package_of_group $GROUP
done

# 
# The End and cleanup
#
_cleanup_tmp_files
#rm -rf $TMPDIR
exit $rc
